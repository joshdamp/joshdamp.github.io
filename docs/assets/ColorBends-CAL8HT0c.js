import{r as e,j as n}from"./index-B7ggBKdf.js";import{V as r,S as t,O as o,P as u,a,b as l,M as s,W as i,c,C as m}from"./vendor-three-0-yjO_2Z.js";import"./vendor-react-B_uAldPx.js";import"./vendor-motion-BEO4XxSi.js";function f({className:f="",style:v,rotation:p=45,speed:d=.2,colors:w=[],transparent:g=!0,autoRotate:h=0,scale:x=1,frequency:y=1,warpStrength:C=1,mouseInfluence:R=1,parallax:S=.5,noise:q=.1}){const k=e.useRef(null),M=e.useRef(null),F=e.useRef(null),E=e.useRef(null),P=e.useRef(null),I=e.useRef(p),T=e.useRef(h),b=e.useRef(new r(0,0)),O=e.useRef(new r(0,0)),W=e.useRef(8),A=e=>{const n=e.replace("#","").trim(),r=3===n.length?[parseInt(n[0]+n[0],16),parseInt(n[1]+n[1],16),parseInt(n[2]+n[2],16)]:[parseInt(n.slice(0,2),16),parseInt(n.slice(2,4),16),parseInt(n.slice(4,6),16)];return new a(r[0]/255,r[1]/255,r[2]/255)};return e.useEffect(()=>{const e=k.current,n=new t,f=new o(-1,1,1,-1,0,1),v=new u(2,2),p=Array.from({length:8},()=>new a(0,0,0)),w=new l({vertexShader:"\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n",fragmentShader:"\n#define MAX_COLORS 8\nuniform vec2 uCanvas;\nuniform float uTime;\nuniform float uSpeed;\nuniform vec2 uRot;\nuniform int uColorCount;\nuniform vec3 uColors[MAX_COLORS];\nuniform int uTransparent;\nuniform float uScale;\nuniform float uFrequency;\nuniform float uWarpStrength;\nuniform vec2 uPointer;\nuniform float uMouseInfluence;\nuniform float uParallax;\nuniform float uNoise;\nvarying vec2 vUv;\n\nvoid main() {\n  float t = uTime * uSpeed;\n  vec2 p = vUv * 2.0 - 1.0;\n  p += uPointer * uParallax * 0.1;\n  vec2 rp = vec2(p.x * uRot.x - p.y * uRot.y, p.x * uRot.y + p.y * uRot.x);\n  vec2 q = vec2(rp.x * (uCanvas.x / uCanvas.y), rp.y);\n  q /= max(uScale, 0.0001);\n  q /= 0.5 + 0.2 * dot(q, q);\n  q += 0.2 * cos(t) - 7.56;\n  vec2 toward = (uPointer - rp);\n  q += toward * uMouseInfluence * 0.2;\n\n    vec3 col = vec3(0.0);\n    float a = 1.0;\n\n    if (uColorCount > 0) {\n      vec2 s = q;\n      vec3 sumCol = vec3(0.0);\n      float cover = 0.0;\n      for (int i = 0; i < MAX_COLORS; ++i) {\n            if (i >= uColorCount) break;\n            s -= 0.01;\n            vec2 r = sin(1.5 * (s.yx * uFrequency) + 2.0 * cos(s * uFrequency));\n            float m0 = length(r + sin(5.0 * r.y * uFrequency - 3.0 * t + float(i)) / 4.0);\n            float kBelow = clamp(uWarpStrength, 0.0, 1.0);\n            float kMix = pow(kBelow, 0.3);\n            float gain = 1.0 + max(uWarpStrength - 1.0, 0.0);\n            vec2 disp = (r - s) * kBelow;\n            vec2 warped = s + disp * gain;\n            float m1 = length(warped + sin(5.0 * warped.y * uFrequency - 3.0 * t + float(i)) / 4.0);\n            float m = mix(m0, m1, kMix);\n            float w = 1.0 - exp(-6.0 / exp(6.0 * m));\n            sumCol += uColors[i] * w;\n            cover = max(cover, w);\n      }\n      col = clamp(sumCol, 0.0, 1.0);\n      a = uTransparent > 0 ? cover : 1.0;\n    } else {\n        vec2 s = q;\n        for (int k = 0; k < 3; ++k) {\n            s -= 0.01;\n            vec2 r = sin(1.5 * (s.yx * uFrequency) + 2.0 * cos(s * uFrequency));\n            float m0 = length(r + sin(5.0 * r.y * uFrequency - 3.0 * t + float(k)) / 4.0);\n            float kBelow = clamp(uWarpStrength, 0.0, 1.0);\n            float kMix = pow(kBelow, 0.3);\n            float gain = 1.0 + max(uWarpStrength - 1.0, 0.0);\n            vec2 disp = (r - s) * kBelow;\n            vec2 warped = s + disp * gain;\n            float m1 = length(warped + sin(5.0 * warped.y * uFrequency - 3.0 * t + float(k)) / 4.0);\n            float m = mix(m0, m1, kMix);\n            col[k] = 1.0 - exp(-6.0 / exp(6.0 * m));\n        }\n        a = uTransparent > 0 ? max(max(col.r, col.g), col.b) : 1.0;\n    }\n\n    if (uNoise > 0.0001) {\n      float n = fract(sin(dot(gl_FragCoord.xy + vec2(uTime), vec2(12.9898, 78.233))) * 43758.5453123);\n      col += (n - 0.5) * uNoise;\n      col = clamp(col, 0.0, 1.0);\n    }\n\n    vec3 rgb = (uTransparent > 0) ? col * a : col;\n    gl_FragColor = vec4(rgb, a);\n}\n",uniforms:{uCanvas:{value:new r(1,1)},uTime:{value:0},uSpeed:{value:d},uRot:{value:new r(1,0)},uColorCount:{value:0},uColors:{value:p},uTransparent:{value:g?1:0},uScale:{value:x},uFrequency:{value:y},uWarpStrength:{value:C},uPointer:{value:new r(0,0)},uMouseInfluence:{value:R},uParallax:{value:S},uNoise:{value:q}},premultipliedAlpha:!0,transparent:g});E.current=w;const h=new s(v,w);n.add(h);const A=new i({antialias:!1,powerPreference:"high-performance",alpha:!0});M.current=A,A.outputColorSpace=c,A.setPixelRatio(Math.min(window.devicePixelRatio||1,2)),A.domElement.style.width="100%",A.domElement.style.height="100%",A.domElement.style.display="block",e.appendChild(A.domElement);const B=new m,L=()=>{const n=e.clientWidth||1,r=e.clientHeight||1;A.setSize(n,r,!1),w.uniforms.uCanvas.value.set(n,r)};if(L(),"ResizeObserver"in window){const n=new ResizeObserver(L);n.observe(e),P.current=n}else window.addEventListener("resize",L);const N=()=>{const e=B.getDelta(),r=B.elapsedTime;w.uniforms.uTime.value=r;const t=(I.current%360+T.current*r)*Math.PI/180,o=Math.cos(t),u=Math.sin(t);w.uniforms.uRot.value.set(o,u);const a=O.current,l=b.current,s=Math.min(1,e*W.current);a.lerp(l,s),w.uniforms.uPointer.value.copy(a),A.render(n,f),F.current=requestAnimationFrame(N)};return F.current=requestAnimationFrame(N),()=>{null!==F.current&&cancelAnimationFrame(F.current),P.current?P.current.disconnect():window.removeEventListener("resize",L),v.dispose(),w.dispose(),A.dispose(),A.domElement&&A.domElement.parentElement===e&&e.removeChild(A.domElement)}},[y,R,q,S,x,d,g,C]),e.useEffect(()=>{const e=E.current;if(!e)return;I.current=p,T.current=h,e.uniforms.uSpeed.value=d,e.uniforms.uScale.value=x,e.uniforms.uFrequency.value=y,e.uniforms.uWarpStrength.value=C,e.uniforms.uMouseInfluence.value=R,e.uniforms.uParallax.value=S,e.uniforms.uNoise.value=q;const n=(w||[]).filter(Boolean).slice(0,8).map(A);for(let r=0;r<8;r++){const t=e.uniforms.uColors.value[r];r<n.length?t.copy(n[r]):t.set(0,0,0)}e.uniforms.uColorCount.value=n.length,e.uniforms.uTransparent.value=g?1:0},[p,h,d,x,y,C,R,S,q,w,g]),e.useEffect(()=>{const e=E.current,n=k.current;if(!e||!n)return;const r=e=>{const r=n.getBoundingClientRect(),t=(e.clientX-r.left)/(r.width||1)*2-1,o=-((e.clientY-r.top)/(r.height||1)*2-1);b.current.set(t,o)};return n.addEventListener("pointermove",r),()=>{n.removeEventListener("pointermove",r)}},[]),n.jsx("div",{ref:k,className:`color-bends-container ${f}`,style:v})}export{f as default};
